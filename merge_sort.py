# Сортировка слиянием (Merge Sort)

def merge_sort(arr):
    # Базовый случай: если список состоит из одного элемента или пустой, возвращаем его
    if len(arr) <= 1:
        return arr
    
    # Разделяем список на две половины
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])  # Рекурсивно сортируем левую часть
    right = merge_sort(arr[mid:])  # Рекурсивно сортируем правую часть
    
    # Объединяем две отсортированные половины
    return merge(left, right)

def merge(left, right):
    result = []  # Создаем новый список для хранения результата
    i = j = 0  # Индексы для обхода левого и правого списков
    
    # Объединяем элементы левого и правого списков в отсортированном порядке
    while i < len(left) and j < len(right):
        if left[i] < right[j]:  # Если элемент левой половины меньше
            result.append(left[i])
            i += 1  # Переходим к следующему элементу в левом списке
        else:  # Иначе добавляем элемент из правого списка
            result.append(right[j])
            j += 1  # Переходим к следующему элементу в правом списке
    
    # Если остались элементы в одном из списков, добавляем их в конец результата
    result.extend(left[i:])  # Добавляем оставшиеся элементы левого списка
    result.extend(right[j:])  # Добавляем оставшиеся элементы правого списка
    return result

# Пример использования
numbers = [64, 34, 25, 12, 22, 11, 90]
print(merge_sort(numbers))  # Вывод: [11, 12, 22, 25, 34, 64, 90]